<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>NSObject | study and record</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="+load和+initialize是NSObject的两个类方法，这两个类方法会在类被使用时主动调用，但是调用时机和调用顺序却截然不同。 先看看苹果的官方文档里面： Initialize ###Initializing a Classclass func initialize()Initializes the class before it receives its first message.">
<meta property="og:type" content="article">
<meta property="og:title" content="NSObject">
<meta property="og:url" content="http://yoursite.com/2020/06/29/NSObject/index.html">
<meta property="og:site_name" content="study and record">
<meta property="og:description" content="+load和+initialize是NSObject的两个类方法，这两个类方法会在类被使用时主动调用，但是调用时机和调用顺序却截然不同。 先看看苹果的官方文档里面： Initialize ###Initializing a Classclass func initialize()Initializes the class before it receives its first message.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-29T14:20:45.000Z">
<meta property="article:modified_time" content="2020-06-29T14:22:19.472Z">
<meta property="article:author" content="y500">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="study and record" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">study and record</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-NSObject" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/29/NSObject/" class="article-date">
  <time datetime="2020-06-29T14:20:45.000Z" itemprop="datePublished">2020-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      NSObject
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>+load和+initialize是NSObject的两个类方法，这两个类方法会在类被使用时主动调用，但是调用时机和调用顺序却截然不同。</p>
<p>先看看苹果的<a href="https://developer.apple.com/documentation/objectivec/nsobject#//apple_ref/occ/cl/NSObject" target="_blank" rel="noopener">官方文档里面</a>：</p>
<h3 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h3><blockquote>
<p>###Initializing a Class<br>class func initialize()<br>Initializes the class before it receives its first message.</p>
</blockquote>
<blockquote>
<p>he runtime sends initialize() to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.<br>The runtime sends the initialize() message to classes in a thread-safe manner. That is, initialize() is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize() completes.<br>The superclass implementation may be called multiple times if subclasses do not implement initialize()—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">  if (self &#x3D;&#x3D; [ClassName self]) &#123;</span><br><span class="line">    &#x2F;&#x2F; ... do the initialization ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Because initialize() is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their initialize() methods is liable to lead to deadlocks. Therefore, you should not rely on initialize() for complex initialization, and should instead limit it to straightforward, class local initialization.</p>
</blockquote>
<blockquote>
<p>initialize() is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement load() methods.</p>
</blockquote>
<ol>
<li><code>initialize</code>方法是在该类接收到第一个消息之前调用.</li>
<li>父类的 <code>initialize</code> 方法先于子类的 <code>initialize</code> 方法调用.</li>
<li>如果子类中没有实现 <code>initialize</code> 方法，或者子类显示调用父类实现 [super initialize], 那么则会调用其父类的实现。也就是说，父类的 <code>initialize</code> 可能会被调用多次。</li>
<li>在应用程序生命周期里，<code>runtime</code> 只会向每个类发送一次 <code>initialize</code> 消息. 所以如果category中实现了<code>initialize</code>方法，那么原来类中的则不会被调用.</li>
</ol>
<p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface SuperObject : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SuperObject</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SubObject : SuperObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubObject</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [SubObject class];</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+[SuperObject initialize]</span><br><span class="line">+[SubObject initialize]</span><br></pre></td></tr></table></figure>

<p>就算把main函数中的<code>[SubObject class]</code>改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SubObject class];</span><br><span class="line">[[SubObject alloc] init];</span><br></pre></td></tr></table></figure>
<p>输出还是一样。</p>
<p>添加一个category：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface SubObject (category)</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubObject (category)</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>输出则为（category中方法覆盖了原类中的方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+[SuperObject initialize]</span><br><span class="line">+[SubObject(category) initialize]</span><br></pre></td></tr></table></figure>

<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><blockquote>
<p>###class func load()<br>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
</blockquote>
<blockquote>
<p>The load() message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.<br>The order of initialization is as follows:</p>
</blockquote>
<pre><code>1. All initializers in any framework you link to.
2. All +load methods in your image.
3. All C++ static initializers and C/C++ __attribute__(constructor) functions in your image.
4. All initializers in frameworks that link to you.</code></pre><blockquote>
<p>In addition:</p>
</blockquote>
<pre><code>* A class’s +load method is called after all of its superclasses’ +load methods.
* A category +load method is called after the class’s own +load method.</code></pre><blockquote>
<p>In a custom implementation of load() you can therefore safely message other unrelated classes from the same image, but any load() methods implemented by those classes may not have run yet.</p>
</blockquote>
<ol>
<li>在类或者category被添加到runtime的时候调用，该调用发生在main函数之前。</li>
<li>父类<code>load</code>方法先于子类调用，类本身<code>load</code>方法先于category中调用。</li>
</ol>
<p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface SuperObject : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SuperObject</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%@, %s&quot;, [self class], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SubObject : SuperObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubObject</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%@, %s&quot;, [self class], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%@, %s&quot;, [self class], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SubObject (category)</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubObject (category)</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%@, %s&quot;, [self class], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%@ %s&quot;, [self class], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        SubObject *subObject &#x3D; [[SubObject alloc] init];</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果（这里有点地方要解释一下，按照文档的说法，<code>load</code>应该咋<code>initialize</code>之前，这里实在之后，原是因为，<code>load</code>方法中调用了<code>class</code>方法，从而触发了<code>initialize</code>方法，所以出现了这种情况）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SuperObject , +[SuperObject initialize]</span><br><span class="line">SuperObject, +[SuperObject load]</span><br><span class="line">SubObject, +[SubObject(category) initialize]</span><br><span class="line">SubObject, +[SubObject load]</span><br><span class="line">SubObject +[SubObject(category) load]</span><br></pre></td></tr></table></figure>

<p>再看一个例子，子类中不实现<code>initialize</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface SuperObject : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SuperObject</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SubObject : SuperObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubObject</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%@, %s&quot;, [self class], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        SubObject *subObject &#x3D; [[SubObject alloc] init];</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下（子类自动调了父类的<code>initialize</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SuperObject , +[SuperObject initialize]</span><br><span class="line">SubObject , +[SuperObject initialize]</span><br><span class="line">SubObject, +[SubObject load]</span><br></pre></td></tr></table></figure>

<p><strong>不需要在<code>load</code>和<code>initialize</code>方法中显式的去调用父类的方法。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/29/NSObject/" data-id="ckc0lxlbc0001ic6gdgbsb61x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/29/JavaScript-Depth-of-Tree/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JavaScript-Depth-of-Tree
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/29/JavaScript-Depth-of-Tree/">JavaScript-Depth-of-Tree</a>
          </li>
        
          <li>
            <a href="/2020/06/29/NSObject/">NSObject</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 y500<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>